# Linux基础——gcc编译静态库与动态库

>[Linux基础——gcc编译、静态库与动态库（共享库）](https://blog.csdn.net/daidaihema/article/details/80902012)
>[动态加载和静态加载](https://www.cnblogs.com/loanhicks/p/7413999.html)

## gcc编译器

### 1、gcc工作流程

![gcc工作流程](../pic/gcc工作流程.png)

### 2、gcc常用参数

|参数|	用途|
|:--:|:-:|
|-v	|查看版本|
|-o	|产生目标输出文件|
|-I+目录	|指定头文件目录|
|-D	|编译时定义宏|
|-O	|没有优化1/缺省值2/优化级别最高3|
|-Wall	|提示更多警告信息|
|-c	|只编译子程序|
|-E	|生成预处理文件|
|-g	|包含调试信息|


## 静态库

### 1、静态库的命名格式

lib + 库的名字 + .a
例：libMyTest.a (MyTest为静态库的名字）

### 2、静态库作用分析
在项目开发过程中，经常出现优秀代码重用现象，又或者提供给第三方功能模块却又不想让其看到源代码，这些时候，通常的做法是将代码封装成库或者框架，生成的静态库要和头文件同时发布。

优点：

寻址方便，速度快
库在链接时被打包到可执行文件中，直接发布可执行程序即可以使用

缺点：

静态库的代码被加载到可执行程序中，因此体积过大
如果静态库的函数发生改变，必须重新编译可执行程序

### 3、静态库的制作与使用

测试代码的目录结构如下：

~~~
test
|-- include
|-- |-- head.h
|-- lib
|-- main.c
|-- src
    |-- add.c
    |-- div.c
    |-- mul.c
    |-- sub.c 
~~~

include中存放的是头文件，lib中存放的是静态（动态）库，src中存放的是源代码，main.c是发布代码。

#### 第一步：得到*.o文件

    gcc *.c -c -I../include
    
~~~
test
|-- include
|-- |-- head.h
|-- lib
|-- main.c
|-- src
    |-- add.c
    |-- add.o
    |-- div.c
    |-- div.o
    |-- mul.c
    |-- mul.o
    |-- sub.c 
    |-- sub.o
~~~

#### 第二步：创建静态库

    ar rcs libMyTest.a *.o       

将所有.o文件打包为静态库，r将文件插入静态库中，c创建静态库，不管库是否存在，s写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。

接下来，将静态库文件移到lib目录下

    mv libMyTest.a ../lib  

~~~
test
|-- include
|-- |-- head.h
|-- lib
    |-- libMyTest.a
|-- main.c
|-- src
    |-- add.c
    |-- add.o
    |-- div.c
    |-- div.o
    |-- mul.c
    |-- mul.o
    |-- sub.c 
    |-- sub.o
~~~

 并查看库中包含的函数等信息

    nm libMyTest.a               


#### 第三步：使用静态库

第一种方法：gcc + 源文件 + -L 静态库路径 + -l静态库名 + -I头文件目录 + -o 可执行文件名

    gcc main.c -L lib -l MyTest -I include -o app

第二种方法：gcc + 源文件 + -I头文件 + libxxx.a + -o 可执行文件名

    gcc main.c -I include lib/libMyTest.a -o app

## 动态库（共享库）

### 1、动态库的命名格式

lib + 库的名字 + .so
例：libMyTest.so (MyTest为动态库的名字）

### 2、动态库作用分析

共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。

优点：

节省内存
易于更新，不用重新编译可执行程序，运行时自动加载

缺点：

延时绑定，速度略慢

### 3、动态库的制作与使用

测试代码的目录结构与静态库相同。

#### 第一步：生成与位置无关的.o文件

    gcc -fPIC *.c -I ../include -c   参数-fPIC表示生成与位置无关代码

~~~
test
|-- include
|-- |-- head.h
|-- lib
|-- main.c
|-- src
    |-- add.c
    |-- add.o
    |-- div.c
    |-- div.o
    |-- mul.c
    |-- mul.o
    |-- sub.c 
    |-- sub.o
~~~

#### 第二步：创建动态库

    gcc -shared -o libMyTest.so *.o  
    mv libMyTest.so ../lib

参数：-shared 制作动态库 -o：重命名生成的新文件

~~~
test
|-- include
|-- |-- head.h
|-- lib
    |-- libMyTest.so
|-- main.c
|-- src
    |-- add.c
    |-- add.o
    |-- div.c
    |-- div.o
    |-- mul.c
    |-- mul.o
    |-- sub.c 
    |-- sub.o
~~~

#### 第三步：使用动态库

第一种方法：gcc + 源文件 + -L 动态库路径 + -l动态库名 + -I头文件目录 + -o 可执行文件名

    gcc main.c -L lib -l MyTest -I include -o app

执行失败，找不到链接库，没有给动态链接器（ld-linux.so.2）指定好动态库 libmytest.so 的路径

第二种方法：gcc + 源文件 + -I头文件 + libxxx.so + -o 可执行文件名

    gcc main.c -I include lib/libMyTest.so -o app

执行成功，已经指明了动态库的路径

**如何解决第一种方法中找不到链接库的问题？**

使用命令ldd app可以查看当前的链接库情况

第一种方法：
export LD_LIBRARY_PATH=自定义动态库的路径（只能起到临时作用，关闭终端后失效）
LD_LIBRARY_PATH ： 指定查找共享库（动态链接库）时除了默认路径之外的其他路径，该路径在默认路径之前查找

第二种方法：
将上述命令写入home目录下的.bashrc文件中，保存后重启终端生效（永久）

第三种方法：
直接将动态库拷贝到user/lib的系统目录下（强烈不推荐！！）

第四种方法：
将libmytest.so所在绝对路径追加入到/etc/ld.so.conf文件，使用sudo ldconfig -v 更新

## 动态加载和静态加载

## 动态加载：

1：灵活，可以在需要的时候用LoadLibrary进行加载，在不需要的时候用FreeLibrary进行卸载，这样可以不必占用内存。
2：可以在没有dll时候发现，而不致程序报错。
3：加载程序中有条件才运行的库。
4：热更新，在不停止程序的前提下进行更新。
5：复杂一些，需要显示获得函数地址。
6：dll没有对应的lib文件，此时只能进行动态加载。
 
## 静态加载：
1：简单方便
2：没有dll时，系统报错
3：加载运行很久的库
4：dll必需有相应的lib文件

加载方法：
1、确保有a.dll和a.lib，两个文件都有的话可以用静态加载的方式。
2、在.cpp文件中通过#pragma comment(lib, "a.lib") 加载lib，并包含相应的头文件，就可以使用dll中的函数了～

## 程序库

所谓"程序库"，简单说，就是包含了数据和执行码的文件。其不能单独执行，可以作为其它执行程序的一部分，来完成执行功能。库的存在，可以使得程序模块化，可以加快程序的再编译，可以实现代码重用，可以使得程序便于升级。

程序库可分三类：静态库，共享库和动态加载库。 

静态库，是在执行程序运行前就已经加入到执行码中，在物理上成为执行程序的一部分；共享库，是在执行程序启动时加载到执行程序中，可以被多个执行程序共享使用。动态加载库，其实并不是一种真正的库类型，应该是一种库的使用技术，应用程序可以在运行过程中随时加载和使用库。 
建议库开发人员创建共享库，比较明显的优势在于库是独立的，便于维护和更新；而静态库的更新比较麻烦，一般不做推荐。然而，它们又各有优点，后面会讲到。在C++编程中，要使用动态加载技术，需要参考文章"C++ dlopen MINI-Howto"。 

静态库可以认为是一些目标代码的集合。按照习惯，一般以".a"做为文件后缀名。使用ar(archiver)命令可以创建静态库。因为共享库有着更大的优势，静态库已经不被经常使用。但静态库使用简单，仍有使用的余地，并会一直存在。 

静态库在应用程序生成时，可以不必再编译，节省再编译时间。但在编译器越来越快的今天，这一点似乎已不重要。如果其他开发人员要使用你的代码，而你又不想给其源码，提供静态库是一种选择。从理论上讲，应用程序使用了静态库，要比使用动态加载库速度快1-5%,但由于莫名的原因，实际上可能并非如此。由此看来，除了使用方便外，静态库可能并非一种好的选择。 