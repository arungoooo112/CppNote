信号量

概念

真实世界类比

利用信号量实现互斥

利用信号量实现前驱关系

利用信号量调度共享资源

    生产者-消费者问题

    读者写者问题



# 信号量
-------

# 信号量的相关概念



**信号量（s）是一种具有非负整数值的全局变量，只能由两种特殊的操作来处理：P(s) 和 V(s)**。是一种经典的解决同步不同执行线程问题的方法。

- P(s)：如果 s > 0，那么 P 将 s 减 1，并立即返回。如果 s = 0，那么就挂起这个线程，直到 s > 0，而一个 V 操作会重启这个线程。重启之后，P 操作将 s 减 1，并将控制返回给调用者。
- V(s)：V 操作将 s 加 1。如果有任何线程阻塞在 P 操作等待 s 变为零，那么 V 操作会重启这些线程中的一个，然后该线程将 s 减 1 ，完成它的 P 操作。

线程同步，指多个线程之间协同配合，步调一致，有序进行。当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。


信号量提供了一种很方便的方法来**确保对共享变量的互斥访问**。基本思想是将每个共享变量（或者一组相关的共享变量）与一个信号量 s（初始为 1）联系起来，然后用 P(s) 和 V(s) 将相应的临界区包围起来。以这种方式来保护共享变量的信号量叫做二元信号量（binary semaphore），因为它们的值总是 0 或者 1。以提供互斥为目的的二元信号量常常也称为互斥锁（mutex）。

# 真实世界类比

# 利用信号量实现互斥
 

# 利用信号量实现前驱关系

# 利用信号量调度共享资源

使用信号量实现生产者-消费者问题

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

~~~c
 #define N 100
 typedef int semaphore;
 
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
~~~
